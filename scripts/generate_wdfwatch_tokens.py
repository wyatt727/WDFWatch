#!/usr/bin/env python3
"""
OAuth 2.0 PKCE flow to generate access tokens for the WDFwatch automated account.
This ensures we post to the correct account, not the managing account.

IMPORTANT: This script will open a browser for you to log in as @WDFwatch 
(the automated account), NOT @WDF_Show (the managing account).

Usage:
    python scripts/generate_wdfwatch_tokens.py
"""

import os
import sys
import secrets
import hashlib
import base64
import webbrowser
from pathlib import Path
from flask import Flask, redirect, request
import requests
import json
from dotenv import load_dotenv
from urllib.parse import urlencode

# Load existing .env to get Client ID
env_path = Path(__file__).parent.parent / ".env"
if env_path.exists():
    load_dotenv(env_path)

app = Flask(__name__)

# OAuth configuration
CLIENT_ID = os.getenv("CLIENT_ID")
CLIENT_SECRET = os.getenv("CLIENT_SECRET")  # May be needed for confidential apps
REDIRECT_URI = "http://localhost:8080/callback"
SCOPE = "tweet.read tweet.write users.read offline.access"

# Global to store code verifier
code_verifier = ""
tokens = {}

def b64url(b: bytes) -> str:
    """Base64 URL-safe encoding without padding."""
    return base64.urlsafe_b64encode(b).decode().rstrip("=")

@app.route("/")
def index():
    return """
    <h1>WDFwatch OAuth Token Generator</h1>
    <p><strong>IMPORTANT:</strong> When you click the button below, you MUST:</p>
    <ol>
        <li>Log out of any existing Twitter/X sessions</li>
        <li>Log in as <strong>@WDFwatch</strong> (the automated account)</li>
        <li>NOT as @WDF_Show (the managing account)</li>
    </ol>
    <p>Account credentials are in .env as AUTOMATED_ACCOUNT and AUTOMATED_ACCOUNT_PW</p>
    <a href="/login" style="display: inline-block; padding: 10px 20px; background: #1DA1F2; color: white; text-decoration: none; border-radius: 5px;">
        Start OAuth Flow for @WDFwatch
    </a>
    """

@app.route("/login")
def login():
    global code_verifier
    
    # Generate PKCE parameters
    code_verifier = b64url(os.urandom(32))
    challenge = b64url(hashlib.sha256(code_verifier.encode()).digest())
    
    # Build authorization URL
    params = {
        "response_type": "code",
        "client_id": CLIENT_ID,
        "redirect_uri": REDIRECT_URI,
        "scope": SCOPE,
        "state": secrets.token_urlsafe(16),
        "code_challenge": challenge,
        "code_challenge_method": "S256"
    }
    
    auth_url = f"https://x.com/i/oauth2/authorize?{urlencode(params)}"
    print(f"\nüîó Opening browser to: {auth_url}\n")
    print("‚ö†Ô∏è  IMPORTANT: Log in as @WDFwatch, NOT @WDF_Show!\n")
    
    return redirect(auth_url)

@app.route("/callback")
def callback():
    global tokens
    
    # Get authorization code from callback
    code = request.args.get("code", "")
    
    if not code:
        return {"error": "No authorization code received"}
    
    # Exchange code for tokens
    token_data = {
        "grant_type": "authorization_code",
        "code": code,
        "code_verifier": code_verifier,
        "redirect_uri": REDIRECT_URI,
        "client_id": CLIENT_ID
    }
    
    # Prepare headers
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    
    # Use Basic Authentication with Client ID and Client Secret
    # This is required for confidential apps
    auth = None
    if CLIENT_ID and CLIENT_SECRET:
        auth = (CLIENT_ID, CLIENT_SECRET)
        print(f"\nüîê Using Basic Auth with Client ID and Secret")
    else:
        print(f"\n‚ö†Ô∏è  No CLIENT_SECRET found, attempting without Basic Auth")
    
    try:
        response = requests.post(
            "https://api.x.com/2/oauth2/token",
            data=token_data,
            headers=headers,
            auth=auth  # requests library handles Basic Auth encoding
        )
        
        if response.status_code == 200:
            tokens = response.json()
            
            # Save tokens to a new env file for the automated account
            env_content = f"""# WDFwatch (automated account) OAuth tokens
# Generated by generate_wdfwatch_tokens.py
# DO NOT COMMIT THIS FILE TO GIT

WDFWATCH_ACCESS_TOKEN={tokens.get('access_token', '')}
WDFWATCH_REFRESH_TOKEN={tokens.get('refresh_token', '')}
WDFWATCH_TOKEN_TYPE={tokens.get('token_type', 'Bearer')}
WDFWATCH_EXPIRES_IN={tokens.get('expires_in', '')}
WDFWATCH_SCOPE={tokens.get('scope', '')}
"""
            
            # Save to .env.wdfwatch
            wdfwatch_env_path = Path(__file__).parent.parent / ".env.wdfwatch"
            wdfwatch_env_path.write_text(env_content)
            
            print(f"\n‚úÖ Tokens saved to: {wdfwatch_env_path}")
            
            # Test the token by getting user info
            user_response = requests.get(
                "https://api.x.com/2/users/me",
                headers={"Authorization": f"Bearer {tokens['access_token']}"}
            )
            
            if user_response.status_code == 200:
                user_data = user_response.json()
                username = user_data.get('data', {}).get('username', 'unknown')
                
                return f"""
                <h1>‚úÖ Success!</h1>
                <p>Successfully generated OAuth tokens for: <strong>@{username}</strong></p>
                <p>Tokens have been saved to: <code>.env.wdfwatch</code></p>
                <h2>‚ö†Ô∏è IMPORTANT:</h2>
                <ul>
                    <li>Verify this is <strong>@WDFwatch</strong>, not @WDF_Show</li>
                    <li>If this shows @WDF_Show, you logged in with the wrong account!</li>
                    <li>Access token expires in: {tokens.get('expires_in', 'unknown')} seconds</li>
                </ul>
                <h2>Next Steps:</h2>
                <ol>
                    <li>Update your scripts to use WDFWATCH_ACCESS_TOKEN instead of ACCESS_TOKEN</li>
                    <li>Test posting with the new tokens</li>
                </ol>
                <p><a href="/shutdown">Click here to stop this server</a></p>
                """
            else:
                return f"""
                <h1>‚ö†Ô∏è Token generated but couldn't verify user</h1>
                <p>Tokens saved but couldn't verify which account they're for.</p>
                <p>Response: {user_response.text}</p>
                """
        else:
            return f"""
            <h1>‚ùå Token Exchange Failed</h1>
            <p>Status: {response.status_code}</p>
            <p>Response: {response.text}</p>
            """
            
    except Exception as e:
        return f"""
        <h1>‚ùå Error</h1>
        <p>{str(e)}</p>
        """

@app.route("/shutdown")
def shutdown():
    func = request.environ.get('werkzeug.server.shutdown')
    if func:
        func()
    return "Server shutting down..."

def main():
    if not CLIENT_ID:
        print("‚ùå CLIENT_ID not found in .env file!")
        print("Please ensure your .env file contains CLIENT_ID from your Twitter app")
        sys.exit(1)
    
    if not CLIENT_SECRET:
        print("‚ö†Ô∏è  CLIENT_SECRET not found in .env file!")
        print("This is required for confidential apps (Web App, Automated App or Bot)")
        print("If your app type requires it, please add CLIENT_SECRET to your .env file")
    
    print("=" * 60)
    print("WDFwatch OAuth Token Generator")
    print("=" * 60)
    print("\n‚ö†Ô∏è  CRITICAL: This will generate tokens for the AUTOMATED account")
    print("              You must log in as @WDFwatch, NOT @WDF_Show!")
    print("\nStarting OAuth server on http://localhost:8080")
    print("Opening browser in 3 seconds...")
    print("\nPress Ctrl+C to cancel\n")
    
    import time
    time.sleep(3)
    
    # Open browser
    webbrowser.open("http://localhost:8080")
    
    # Start Flask server
    app.run(port=8080, debug=False)

if __name__ == "__main__":
    main()