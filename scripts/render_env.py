#!/usr/bin/env python3
"""
Environment variable rendering script.
Merges config/safe_defaults.json with secrets from environment or secrets manager.
"""

import json
import os
import sys
from pathlib import Path
from typing import Dict, Any, Optional

# Project root
PROJECT_ROOT = Path(__file__).parent.parent


def load_safe_defaults() -> Dict[str, Any]:
    """Load safe default configuration from config/safe_defaults.json."""
    defaults_path = PROJECT_ROOT / "config" / "safe_defaults.json"
    
    if not defaults_path.exists():
        print(f"Warning: {defaults_path} not found, using empty defaults")
        return {}
    
    with open(defaults_path, "r") as f:
        return json.load(f)


def load_secrets_from_env() -> Dict[str, str]:
    """Load secrets from environment variables (prefixed with SECRET_)."""
    secrets = {}
    
    # Common secret environment variables
    secret_keys = [
        "DATABASE_URL",
        "REDIS_URL",
        "REDIS_PASSWORD",
        "NEXTAUTH_SECRET",
        "API_KEY",
        "WEB_API_KEY",
        "TWITTER_API_KEY",
        "TWITTER_API_SECRET",
        "TWITTER_ACCESS_TOKEN",
        "TWITTER_ACCESS_TOKEN_SECRET",
        "WDFWATCH_ACCESS_TOKEN",
        "WDFWATCH_REFRESH_TOKEN",
        "WDFWATCH_CLIENT_ID",
        "WDFWATCH_CLIENT_SECRET",
    ]
    
    for key in secret_keys:
        value = os.getenv(key)
        if value:
            secrets[key] = value
    
    return secrets


def load_secrets_from_file(secrets_file: Optional[Path] = None) -> Dict[str, str]:
    """Load secrets from a file (e.g., from secrets manager or .env file)."""
    if secrets_file is None:
        # Try to find .env.secrets or similar
        secrets_file = PROJECT_ROOT / ".env.secrets"
    
    if not secrets_file.exists():
        return {}
    
    secrets = {}
    with open(secrets_file, "r") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            
            if "=" in line:
                key, value = line.split("=", 1)
                key = key.strip()
                value = value.strip().strip('"').strip("'")
                secrets[key] = value
    
    return secrets


def merge_config(
    defaults: Dict[str, Any],
    env_secrets: Dict[str, str],
    file_secrets: Dict[str, str],
    override_env: bool = True
) -> Dict[str, str]:
    """
    Merge configuration sources.
    
    Priority order (highest to lowest):
    1. Environment secrets (SECRET_* vars)
    2. File secrets (.env.secrets)
    3. Safe defaults (config/safe_defaults.json)
    """
    config = {}
    
    # Start with safe defaults
    if "settings" in defaults:
        for key, value in defaults["settings"].items():
            env_key = f"WDF_{key.upper()}"
            config[env_key] = str(value)
    
    # Add file secrets
    config.update(file_secrets)
    
    # Override with environment secrets (highest priority)
    if override_env:
        config.update(env_secrets)
    
    return config


def render_env_file(config: Dict[str, str], output_path: Path, template_path: Optional[Path] = None):
    """Render environment file from configuration."""
    if template_path and template_path.exists():
        # Use template file as base
        with open(template_path, "r") as f:
            lines = f.readlines()
        
        output_lines = []
        for line in lines:
            if line.strip().startswith("#"):
                output_lines.append(line)
                continue
            
            if "=" in line:
                key = line.split("=", 1)[0].strip()
                if key in config:
                    output_lines.append(f"{key}={config[key]}\n")
                else:
                    output_lines.append(line)
            else:
                output_lines.append(line)
        
        with open(output_path, "w") as f:
            f.writelines(output_lines)
    else:
        # Generate from scratch
        with open(output_path, "w") as f:
            f.write("# Generated environment file\n")
            f.write(f"# Generated by: {Path(__file__).name}\n")
            f.write(f"# DO NOT EDIT - This file is auto-generated\n\n")
            
            for key, value in sorted(config.items()):
                f.write(f"{key}={value}\n")


def main():
    """Main entrypoint."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Render environment files from configuration")
    parser.add_argument(
        "--template",
        type=Path,
        help="Template file to use (e.g., .env.production.example)"
    )
    parser.add_argument(
        "--secrets-file",
        type=Path,
        help="Secrets file to load (e.g., .env.secrets)"
    )
    parser.add_argument(
        "--output",
        type=Path,
        required=True,
        help="Output file path (e.g., .env.production)"
    )
    parser.add_argument(
        "--no-env-override",
        action="store_true",
        help="Don't override with environment variables"
    )
    
    args = parser.parse_args()
    
    # Load configuration
    defaults = load_safe_defaults()
    env_secrets = load_secrets_from_env() if not args.no_env_override else {}
    file_secrets = load_secrets_from_file(args.secrets_file) if args.secrets_file else {}
    
    # Merge configuration
    config = merge_config(defaults, env_secrets, file_secrets, override_env=not args.no_env_override)
    
    # Render output file
    output_path = args.output if args.output.is_absolute() else PROJECT_ROOT / args.output
    template_path = args.template if args.template else None
    
    if template_path and not template_path.is_absolute():
        template_path = PROJECT_ROOT / template_path
    
    render_env_file(config, output_path, template_path)
    
    print(f"âœ… Generated environment file: {output_path}")
    print(f"   Loaded {len(config)} configuration variables")
    
    if env_secrets:
        print(f"   Used {len(env_secrets)} environment variables")
    if file_secrets:
        print(f"   Used {len(file_secrets)} file secrets")


if __name__ == "__main__":
    main()

