"""
Claude tweet response generation task

This module generates responses to relevant tweets using Claude via the CLI.
It wraps the claude-response.py script to integrate with the pipeline.
Integrates with: web_bridge.py (when WDF_WEB_MODE=true), main.py
"""

import json
import logging
import os
import subprocess
import sys
from pathlib import Path
from typing import Optional

# Fix imports for direct execution
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

import structlog
from prometheus_client import Counter, Histogram

try:
    from ..settings import settings
    from ..episode_files import get_episode_file_manager
except ImportError:
    from src.wdf.settings import settings
    from src.wdf.episode_files import get_episode_file_manager

# Import web bridge for draft creation
try:
    web_scripts_path = Path(__file__).parent.parent.parent.parent / "web" / "scripts"
    sys.path.insert(0, str(web_scripts_path))
    from web_bridge import create_draft_if_web_mode
    HAS_WEB_BRIDGE = True
except ImportError:
    HAS_WEB_BRIDGE = False
    def create_draft_if_web_mode(tweet_id, response, model):
        return None

# Set up structured logging
logger = structlog.get_logger()

# Prometheus metrics
CLAUDE_LATENCY = Histogram(
    "claude_latency_seconds", 
    "Time taken to generate tweet responses with Claude",
    ["run_id"],
    buckets=[1, 5, 10, 30, 60, 120, 300]
)
RESPONSES_GENERATED = Counter(
    "claude_responses_generated_total",
    "Number of tweet responses generated by Claude"
)
CLAUDE_ERRORS = Counter(
    "claude_errors_total",
    "Number of Claude generation errors"
)

# Path to the Claude response script
CLAUDE_SCRIPT = Path(__file__).parent.parent.parent.parent / "claude-tweet-responder" / "claude-response.py"


def run(run_id: str = None, model: str = None, num_workers: int = 1, episode_id: str = None) -> Path:
    """
    Run the Claude response generation task.
    
    This function wraps the claude-response.py script to maintain compatibility
    with the existing pipeline interface.
    
    Args:
        run_id: Optional run ID for artefact storage
        model: Ignored (Claude always uses Sonnet)
        num_workers: Ignored (Claude processes sequentially)
        episode_id: Optional episode ID for file management
        
    Returns:
        Path: Path to the responses file
    """
    logger.info(
        "Starting Claude response generation task",
        run_id=run_id,
        episode_id=episode_id
    )
    
    # Use episode file manager if episode_id provided
    use_episode_files = episode_id or os.environ.get('WDF_EPISODE_ID')
    if use_episode_files:
        file_manager = get_episode_file_manager(episode_id)
        logger.info(
            "Using episode file manager",
            episode_dir=file_manager.episode_dir
        )
        input_path = file_manager.get_output_path('classified')
        output_path = file_manager.get_output_path('responses')
    else:
        input_path = Path(settings.transcript_dir) / "classified.json"
        output_path = Path(settings.transcript_dir) / "responses.json"
    
    # Create artefacts directory if run_id is provided
    artefact_responses = None
    if run_id:
        artefact_dir = settings.get_run_dir(run_id)
        artefact_dir.mkdir(parents=True, exist_ok=True)
        artefact_responses = artefact_dir / "responses.json"
    
    # Build command to run Claude response script
    # Use absolute paths for input/output
    cmd = [
        sys.executable,
        str(CLAUDE_SCRIPT),
        "--batch",
        "--input", str(input_path.resolve()),
        "--output", str(output_path.resolve()),
        # No rate limit with MAX20 plan
        "--rate-limit", "0"
    ]
    
    logger.info(
        "Running Claude response script",
        command=" ".join(cmd),
        input_file=str(input_path),
        output_file=str(output_path)
    )
    
    # Run the script
    with CLAUDE_LATENCY.labels(run_id=run_id or "unknown").time():
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False,
                cwd=str(CLAUDE_SCRIPT.parent)  # Run from claude-tweet-responder directory
            )
            
            if result.returncode != 0:
                logger.error(
                    "Claude response script failed",
                    returncode=result.returncode,
                    stderr=result.stderr[-1000:]  # Last 1000 chars of error
                )
                CLAUDE_ERRORS.inc()
                raise RuntimeError(f"Claude response generation failed: {result.stderr}")
            
            # Log output
            if result.stdout:
                for line in result.stdout.strip().split('\n')[-10:]:  # Last 10 lines
                    logger.info(f"Claude output: {line}")
            
        except Exception as e:
            logger.error(
                "Error running Claude response script",
                error=str(e)
            )
            CLAUDE_ERRORS.inc()
            raise
    
    # Process web bridge integration if available
    if HAS_WEB_BRIDGE and os.getenv("WDF_WEB_MODE", "false").lower() == "true":
        try:
            # Load the responses to create drafts in database
            with open(output_path, 'r') as f:
                tweets = json.load(f)
            
            drafts_created = 0
            for tweet in tweets:
                if tweet.get("response") and tweet.get("status") == "pending":
                    try:
                        draft_id = create_draft_if_web_mode(
                            tweet.get("id"),
                            tweet.get("response"),
                            "claude-sonnet"
                        )
                        if draft_id:
                            drafts_created += 1
                    except Exception as e:
                        logger.warning(
                            "Failed to create draft in web UI",
                            tweet_id=tweet.get("id"),
                            error=str(e)
                        )
            
            if drafts_created > 0:
                logger.info(
                    "Created drafts in web UI database",
                    count=drafts_created
                )
        except Exception as e:
            logger.warning(
                "Failed to process web bridge integration",
                error=str(e)
            )
    
    # Copy to artefacts directory if run_id is provided
    if run_id and artefact_responses:
        try:
            import shutil
            shutil.copy2(output_path, artefact_responses)
            logger.info(
                "Copied responses to artefacts directory",
                path=str(artefact_responses)
            )
        except Exception as e:
            logger.warning(
                "Failed to copy to artefacts",
                error=str(e)
            )
    
    # Count responses generated
    try:
        with open(output_path, 'r') as f:
            tweets = json.load(f)
            response_count = sum(1 for t in tweets if t.get("response"))
            RESPONSES_GENERATED.inc(response_count)
            logger.info(
                "Claude response generation complete",
                total_responses=response_count
            )
    except:
        pass
    
    return output_path


if __name__ == "__main__":
    # Configure logging when run directly
    logging.basicConfig(level=logging.INFO)
    structlog.configure(
        processors=[
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.JSONRenderer()
        ]
    )
    
    # Set up argument parser for command line usage
    import argparse
    parser = argparse.ArgumentParser(description="Generate responses to relevant tweets using Claude")
    parser.add_argument("--run-id", type=str, help="Run ID for artefact storage")
    parser.add_argument("--episode-id", type=str, help="Episode ID for file management")
    args = parser.parse_args()
    
    # Run the task
    output_path = run(run_id=args.run_id, episode_id=args.episode_id)
    print(f"Responses saved to: {output_path}")